// D3.js Enhanced Compass for Feng Shui App
class D3Compass {
  constructor(containerId, options = {}) {
    this.container = d3.select(containerId);
    this.width = options.width || 600;
    this.height = options.height || 600;
    this.radius = Math.min(this.width, this.height) / 2 - 20;
    this.currentAngle = 0;
    this.selectedSector = null;
    
    // Bagua sectors data
    this.sectors = [
      { name: 'KHẢM', symbol: '☵', element: 'Thủy', meaning: 'Nghiệp', color: '#1e40af', angle: 0 },
      { name: 'CẤN', symbol: '☶', element: 'Thổ', meaning: 'Tri thức', color: '#a16207', angle: 45 },
      { name: 'CHẤN', symbol: '☳', element: 'Mộc', meaning: 'Gia đình', color: '#16a34a', angle: 90 },
      { name: 'TỐN', symbol: '☴', element: 'Mộc', meaning: 'Tài lộc', color: '#059669', angle: 135 },
      { name: 'LY', symbol: '☲', element: 'Hỏa', meaning: 'Danh tiếng', color: '#dc2626', angle: 180 },
      { name: 'KHÔN', symbol: '☷', element: 'Thổ', meaning: 'Tình duyên', color: '#ea580c', angle: 225 },
      { name: 'ĐOÀI', symbol: '☱', element: 'Kim', meaning: 'Con cái', color: '#6b7280', angle: 270 },
      { name: 'CÀN', symbol: '☰', element: 'Kim', meaning: 'Quý nhân', color: '#4b5563', angle: 315 }
    ];
    
    this.directions = [
      { name: 'Bắc', angle: 0 },
      { name: 'Đông Bắc', angle: 45 },
      { name: 'Đông', angle: 90 },
      { name: 'Đông Nam', angle: 135 },
      { name: 'Nam', angle: 180 },
      { name: 'Tây Nam', angle: 225 },
      { name: 'Tây', angle: 270 },
      { name: 'Tây Bắc', angle: 315 }
    ];
    
    this.init();
  }
  
  init() {
    // Clear container
    this.container.selectAll('*').remove();
    
    // Create SVG
    this.svg = this.container
      .append('svg')
      .attr('width', this.width)
      .attr('height', this.height)
      .attr('class', 'w-full h-auto')
      .style('background', 'transparent');
    
    // Create main group
    this.g = this.svg
      .append('g')
      .attr('transform', `translate(${this.width / 2}, ${this.height / 2})`);
    
    // Add glow filter
    this.addGlowFilter();
    
    // Draw compass components
    this.drawBackground();
    this.drawSectors();
    this.drawCenterCircle();
    this.drawNeedle();
    this.drawDirections();
    this.drawDegreeMarkers();
    
    // Add interactivity
    this.addInteractivity();
  }
  
  addGlowFilter() {
    const defs = this.svg.append('defs');
    
    // Glow filter for highlights
    const glowFilter = defs.append('filter')
      .attr('id', 'glow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
    
    glowFilter.append('feGaussianBlur')
      .attr('stdDeviation', '4')
      .attr('result', 'coloredBlur');
    
    const feMerge = glowFilter.append('feMerge');
    feMerge.append('feMergeNode').attr('in', 'coloredBlur');
    feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
    
    // Drop shadow filter
    const shadowFilter = defs.append('filter')
      .attr('id', 'dropshadow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
    
    shadowFilter.append('feDropShadow')
      .attr('dx', '0')
      .attr('dy', '4')
      .attr('stdDeviation', '8')
      .attr('flood-color', '#000000')
      .attr('flood-opacity', '0.2');
    
    // Gradients for realistic look
    const compassGradient = defs.append('radialGradient')
      .attr('id', 'compassGradient')
      .attr('cx', '50%')
      .attr('cy', '30%');
    
    compassGradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', '#ffffff')
      .attr('stop-opacity', '0.8');
    
    compassGradient.append('stop')
      .attr('offset', '70%')
      .attr('stop-color', '#f8fafc')
      .attr('stop-opacity', '0.4');
    
    compassGradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', '#e2e8f0')
      .attr('stop-opacity', '0.2');
    
    // Metallic border gradient
    const borderGradient = defs.append('linearGradient')
      .attr('id', 'borderGradient')
      .attr('x1', '0%')
      .attr('y1', '0%')
      .attr('x2', '100%')
      .attr('y2', '100%');
    
    borderGradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', '#ffd700');
    
    borderGradient.append('stop')
      .attr('offset', '50%')
      .attr('stop-color', '#ffed4e');
    
    borderGradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', '#d4af37');
    
    // Center gradient
    const centerGradient = defs.append('radialGradient')
      .attr('id', 'centerGradient')
      .attr('cx', '50%')
      .attr('cy', '30%');
    
    centerGradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', '#fbbf24');
    
    centerGradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', '#d97706');
  }
  
  drawBackground() {
    // Outer metallic ring - realistic compass border
    this.g.append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', this.radius + 5)
      .attr('fill', 'url(#borderGradient)')
      .attr('filter', 'url(#dropshadow)');
    
    // Main compass face with realistic gradient
    this.g.append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', this.radius)
      .attr('fill', 'url(#compassGradient)')
      .attr('stroke', '#d4af37')
      .attr('stroke-width', 2);
    
    // Inner graduation circle
    this.g.append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', this.radius - 25)
      .attr('fill', 'none')
      .attr('stroke', '#cbd5e1')
      .attr('stroke-width', 1)
      .attr('opacity', 0.5);
    
    // Add tick marks around the compass (360 degrees)
    for (let i = 0; i < 360; i += 5) {
      const angle = (i - 90) * (Math.PI / 180);
      const isMainTick = i % 30 === 0;
      const tickLength = isMainTick ? 15 : 8;
      const strokeWidth = isMainTick ? 2 : 1;
      const opacity = isMainTick ? 0.8 : 0.4;
      
      const x1 = Math.cos(angle) * (this.radius - 5);
      const y1 = Math.sin(angle) * (this.radius - 5);
      const x2 = Math.cos(angle) * (this.radius - 5 - tickLength);
      const y2 = Math.sin(angle) * (this.radius - 5 - tickLength);
      
      this.g.append('line')
        .attr('x1', x1)
        .attr('y1', y1)
        .attr('x2', x2)
        .attr('y2', y2)
        .attr('stroke', '#374151')
        .attr('stroke-width', strokeWidth)
        .attr('opacity', opacity);
    }
  }
  
  drawSectors() {
    const pie = d3.pie()
      .value(1)
      .startAngle(0)
      .endAngle(2 * Math.PI)
      .sort(null);
    
    const arc = d3.arc()
      .innerRadius(80)
      .outerRadius(this.radius - 35)
      .cornerRadius(2); // Rounded corners for modern look
    
    const sectorGroups = this.g.selectAll('.sector')
      .data(pie(this.sectors))
      .enter()
      .append('g')
      .attr('class', 'sector')
      .style('cursor', 'pointer');
    
    // Draw sector paths with realistic gradients
    sectorGroups.each((d, i) => {
      const sector = this.sectors[i];
      const group = d3.select(sectorGroups.nodes()[i]);
      
      // Create individual gradient for each sector
      const gradientId = `sectorGradient${i}`;
      const gradient = this.svg.select('defs').append('radialGradient')
        .attr('id', gradientId)
        .attr('cx', '30%')
        .attr('cy', '30%');
      
      gradient.append('stop')
        .attr('offset', '0%')
        .attr('stop-color', d3.color(sector.color).brighter(0.8));
      
      gradient.append('stop')
        .attr('offset', '70%')
        .attr('stop-color', sector.color);
      
      gradient.append('stop')
        .attr('offset', '100%')
        .attr('stop-color', d3.color(sector.color).darker(0.3));
      
      // Draw sector with gradient
      group.append('path')
        .attr('d', arc)
        .attr('fill', `url(#${gradientId})`)
        .attr('stroke', 'rgba(255, 255, 255, 0.8)')
        .attr('stroke-width', 2)
        .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))')
        .on('mouseover', (event, d) => this.onSectorHover(event, d))
        .on('mouseout', (event, d) => this.onSectorOut(event, d))
        .on('click', (event, d) => this.onSectorClick(event, d));
    });
    
    // Add sector labels with better typography
    sectorGroups.append('text')
      .attr('transform', (d) => {
        const [x, y] = arc.centroid(d);
        return `translate(${x}, ${y - 20})`;
      })
      .attr('text-anchor', 'middle')
      .attr('fill', 'white')
      .attr('font-size', '13px')
      .attr('font-weight', '600')
      .attr('font-family', 'Inter, system-ui, sans-serif')
      .style('text-shadow', '0 1px 3px rgba(0,0,0,0.5)')
      .text((d, i) => this.sectors[i].name);
    
    // Add trigram symbols with better positioning
    sectorGroups.append('text')
      .attr('transform', (d) => {
        const [x, y] = arc.centroid(d);
        return `translate(${x}, ${y + 5})`;
      })
      .attr('text-anchor', 'middle')
      .attr('fill', 'white')
      .attr('font-size', '22px')
      .style('text-shadow', '0 1px 3px rgba(0,0,0,0.5)')
      .text((d, i) => this.sectors[i].symbol);
    
    // Add elements with refined styling
    sectorGroups.append('text')
      .attr('transform', (d) => {
        const [x, y] = arc.centroid(d);
        return `translate(${x}, ${y + 25})`;
      })
      .attr('text-anchor', 'middle')
      .attr('fill', 'rgba(255, 255, 255, 0.9)')
      .attr('font-size', '10px')
      .attr('font-weight', '500')
      .attr('font-family', 'Inter, system-ui, sans-serif')
      .style('text-shadow', '0 1px 2px rgba(0,0,0,0.4)')
      .text((d, i) => this.sectors[i].element);
  }
  
  drawCenterCircle() {
    // Outer center ring with metallic look
    this.g.append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', 75)
      .attr('fill', 'none')
      .attr('stroke', 'url(#borderGradient)')
      .attr('stroke-width', 3)
      .attr('opacity', 0.8);
    
    // Main center circle with realistic gradient
    this.g.append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', 70)
      .attr('fill', 'url(#centerGradient)')
      .attr('stroke', '#dc2626')
      .attr('stroke-width', 2)
      .attr('filter', 'url(#dropshadow)');
    
    // Inner highlight circle
    this.g.append('circle')
      .attr('cx', -10)
      .attr('cy', -15)
      .attr('r', 20)
      .attr('fill', 'rgba(255, 255, 255, 0.3)')
      .attr('opacity', 0.6);
    
    // Center text with better typography
    this.g.append('text')
      .attr('x', 0)
      .attr('y', -25)
      .attr('text-anchor', 'middle')
      .attr('fill', '#7c2d12')
      .attr('font-size', '11px')
      .attr('font-weight', '600')
      .attr('font-family', 'Inter, system-ui, sans-serif')
      .style('text-shadow', '0 1px 2px rgba(255,255,255,0.5)')
      .text('MỆNH CUNG');
    
    // Yin-yang symbol with better styling
    this.g.append('text')
      .attr('x', 0)
      .attr('y', 8)
      .attr('text-anchor', 'middle')
      .attr('fill', '#7c2d12')
      .attr('font-size', '32px')
      .style('text-shadow', '0 2px 4px rgba(0,0,0,0.2)')
      .text('☯');
    
    // Dynamic destiny text
    this.destinyText = this.g.append('text')
      .attr('x', 0)
      .attr('y', 35)
      .attr('text-anchor', 'middle')
      .attr('fill', '#7c2d12')
      .attr('font-size', '13px')
      .attr('font-weight', '700')
      .attr('font-family', 'Inter, system-ui, sans-serif')
      .style('text-shadow', '0 1px 2px rgba(255,255,255,0.5)')
      .text('ĐOÀI');
  }
  
  drawNeedle() {
    // Needle shadow
    this.needleGroup = this.g.append('g')
      .attr('class', 'needle')
      .style('transition', 'transform 0.8s cubic-bezier(0.4, 0.0, 0.2, 1)');
    
    // Needle shaft with gradient
    const needleGradient = this.svg.select('defs').append('linearGradient')
      .attr('id', 'needleGradient')
      .attr('x1', '0%')
      .attr('y1', '0%')
      .attr('x2', '100%')
      .attr('y2', '0%');
    
    needleGradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', '#ef4444');
    
    needleGradient.append('stop')
      .attr('offset', '50%')
      .attr('stop-color', '#dc2626');
    
    needleGradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', '#b91c1c');
    
    // Main needle line with realistic look
    this.needleGroup.append('line')
      .attr('x1', 0)
      .attr('y1', 0)
      .attr('x2', 0)
      .attr('y2', -this.radius + 50)
      .attr('stroke', 'url(#needleGradient)')
      .attr('stroke-width', 4)
      .attr('stroke-linecap', 'round')
      .style('filter', 'drop-shadow(0 2px 4px rgba(220, 38, 38, 0.4))');
    
    // Needle tip with 3D effect
    this.needleGroup.append('polygon')
      .attr('points', `-6,-${this.radius - 50} 0,-${this.radius - 25} 6,-${this.radius - 50}`)
      .attr('fill', 'url(#needleGradient)')
      .style('filter', 'drop-shadow(0 1px 2px rgba(0,0,0,0.3))');
    
    // Center pivot with metallic look
    this.needleGroup.append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', 8)
      .attr('fill', 'url(#borderGradient)')
      .attr('stroke', '#7c2d12')
      .attr('stroke-width', 1)
      .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))');
    
    // Inner pivot dot
    this.needleGroup.append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', 3)
      .attr('fill', '#dc2626');
  }
  
  drawDirections() {
    const cardinalDirections = [
      { name: 'BẮC', angle: 0, size: '16px', weight: '700' },
      { name: 'ĐÔNG', angle: 90, size: '16px', weight: '700' },
      { name: 'NAM', angle: 180, size: '16px', weight: '700' },
      { name: 'TÂY', angle: 270, size: '16px', weight: '700' }
    ];
    
    const intermediateDirections = [
      { name: 'ĐB', angle: 45, size: '13px', weight: '600' },
      { name: 'ĐN', angle: 135, size: '13px', weight: '600' },
      { name: 'TN', angle: 225, size: '13px', weight: '600' },
      { name: 'TB', angle: 315, size: '13px', weight: '600' }
    ];
    
    // Draw cardinal directions with prominence
    cardinalDirections.forEach(dir => {
      const angle = (dir.angle - 90) * (Math.PI / 180);
      const x = Math.cos(angle) * (this.radius + 25);
      const y = Math.sin(angle) * (this.radius + 25);
      
      // Background circle for cardinal directions
      this.g.append('circle')
        .attr('cx', x)
        .attr('cy', y)
        .attr('r', 18)
        .attr('fill', 'rgba(255, 255, 255, 0.9)')
        .attr('stroke', '#d4af37')
        .attr('stroke-width', 2)
        .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))');
      
      this.g.append('text')
        .attr('x', x)
        .attr('y', y + 2)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('fill', '#1f2937')
        .attr('font-size', dir.size)
        .attr('font-weight', dir.weight)
        .attr('font-family', 'Inter, system-ui, sans-serif')
        .text(dir.name);
    });
    
    // Draw intermediate directions
    intermediateDirections.forEach(dir => {
      const angle = (dir.angle - 90) * (Math.PI / 180);
      const x = Math.cos(angle) * (this.radius + 15);
      const y = Math.sin(angle) * (this.radius + 15);
      
      this.g.append('text')
        .attr('x', x)
        .attr('y', y + 1)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('fill', '#4b5563')
        .attr('font-size', dir.size)
        .attr('font-weight', dir.weight)
        .attr('font-family', 'Inter, system-ui, sans-serif')
        .text(dir.name);
    });
  }
  
  drawDegreeMarkers() {
    // Major degree markers (every 30°) with labels
    for (let degree = 0; degree < 360; degree += 30) {
      const angle = (degree - 90) * (Math.PI / 180);
      const x1 = Math.cos(angle) * (this.radius - 15);
      const y1 = Math.sin(angle) * (this.radius - 15);
      const x2 = Math.cos(angle) * (this.radius - 30);
      const y2 = Math.sin(angle) * (this.radius - 30);
      
      // Major tick marks
      this.g.append('line')
        .attr('x1', x1)
        .attr('y1', y1)
        .attr('x2', x2)
        .attr('y2', y2)
        .attr('stroke', '#374151')
        .attr('stroke-width', 2)
        .attr('opacity', 0.8);
      
      // Degree labels for major marks
      const textX = Math.cos(angle) * (this.radius - 40);
      const textY = Math.sin(angle) * (this.radius - 40);
      
      this.g.append('text')
        .attr('x', textX)
        .attr('y', textY + 2)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('fill', '#374151')
        .attr('font-size', '11px')
        .attr('font-weight', '500')
        .attr('font-family', 'Inter, system-ui, sans-serif')
        .text(degree + '°');
    }
    
    // Minor degree markers (every 15°)
    for (let degree = 15; degree < 360; degree += 30) {
      const angle = (degree - 90) * (Math.PI / 180);
      const x1 = Math.cos(angle) * (this.radius - 15);
      const y1 = Math.sin(angle) * (this.radius - 15);
      const x2 = Math.cos(angle) * (this.radius - 25);
      const y2 = Math.sin(angle) * (this.radius - 25);
      
      this.g.append('line')
        .attr('x1', x1)
        .attr('y1', y1)
        .attr('x2', x2)
        .attr('y2', y2)
        .attr('stroke', '#6b7280')
        .attr('stroke-width', 1)
        .attr('opacity', 0.6);
    }
  }
  
  addInteractivity() {
    // Remove zoom functionality - keep compass at fixed size
    // Only keep sector click and hover interactions
  }
  
  onSectorHover(event, d) {
    const sector = this.sectors[d.index];
    
    // Highlight sector
    d3.select(event.target)
      .transition()
      .duration(200)
      .attr('fill-opacity', 0.9)
      .attr('stroke-width', 4);
    
    // Update info panel
    this.updateInfoPanel(sector);
  }
  
  onSectorOut(event, d) {
    d3.select(event.target)
      .transition()
      .duration(200)
      .attr('fill-opacity', 0.7)
      .attr('stroke-width', 3);
  }
  
  onSectorClick(event, d) {
    const sector = this.sectors[d.index];
    this.selectedSector = sector;
    
    // Rotate needle to sector
    this.rotateNeedle(sector.angle);
    
    // Update destiny text
    this.destinyText
      .transition()
      .duration(500)
      .style('font-size', '16px')
      .text(sector.name)
      .transition()
      .duration(200)
      .style('font-size', '14px');
    
    // Update info panel with detailed information
    this.updateInfoPanel(sector, true);
  }
  
  rotateNeedle(angle) {
    this.currentAngle = angle;
    this.needleGroup
      .transition()
      .duration(800)
      .ease(d3.easeElasticOut)
      .attr('transform', `rotate(${angle})`);
  }
  
  updateInfoPanel(sector, detailed = false) {
    // Update compass info elements
    const directionElement = document.getElementById('compass-dir');
    const degreeElement = document.getElementById('compass-deg');
    const trigramElement = document.getElementById('compass-trigram');
    const elementElement = document.getElementById('compass-element');
    const meaningElement = document.getElementById('compass-meaning');
    const sectorInfoElement = document.getElementById('compass-sector-info');
    
    if (directionElement) {
      const direction = this.directions.find(d => d.angle === sector.angle);
      directionElement.textContent = direction ? direction.name : 'N/A';
    }
    
    if (degreeElement) {
      degreeElement.textContent = sector.angle;
    }
    
    if (trigramElement) {
      trigramElement.textContent = `${sector.name} ${sector.symbol}`;
    }
    
    if (elementElement) {
      elementElement.textContent = sector.element;
    }
    
    if (meaningElement) {
      meaningElement.textContent = sector.meaning;
    }
    
    if (sectorInfoElement && detailed) {
      sectorInfoElement.innerHTML = `
        <div class="space-y-2">
          <h4 class="font-bold text-feng-shui-red">${sector.name} ${sector.symbol}</h4>
          <p><strong>Nguyên tố:</strong> ${sector.element}</p>
          <p><strong>Ý nghĩa:</strong> ${sector.meaning}</p>
          <p><strong>Góc:</strong> ${sector.angle}°</p>
          <p class="text-sm text-gray-600 mt-2">Cung này đại diện cho khía cạnh ${sector.meaning.toLowerCase()} trong cuộc sống, thuộc nguyên tố ${sector.element}.</p>
        </div>
      `;
    }
  }
  
  // Public methods
  setAngle(angle) {
    this.rotateNeedle(angle);
    const sector = this.getSectorByAngle(angle);
    if (sector) {
      this.updateInfoPanel(sector);
    }
  }
  
  getSectorByAngle(angle) {
    // Normalize angle to 0-360
    angle = ((angle % 360) + 360) % 360;
    
    // Find closest sector (each sector spans 45°)
    const sectorIndex = Math.round(angle / 45) % 8;
    return this.sectors[sectorIndex];
  }
  
  startCompass() {
    if (navigator.geolocation && 'DeviceOrientationEvent' in window) {
      window.addEventListener('deviceorientation', (event) => {
        if (event.alpha !== null) {
          const heading = 360 - event.alpha;
          this.setAngle(heading);
        }
      });
    }
  }
  
  stopCompass() {
    window.removeEventListener('deviceorientation', this.handleOrientation);
  }
}

// Initialize compass when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  // Wait for D3 to load
  if (typeof d3 !== 'undefined') {
    initD3Compass();
  } else {
    // Retry after a short delay
    setTimeout(initD3Compass, 100);
  }
});

function initD3Compass() {
  const compassContainer = document.querySelector('#d3-compass-container');
  if (compassContainer && typeof d3 !== 'undefined') {
    window.d3Compass = new D3Compass('#d3-compass-container', {
      width: 500,
      height: 500
    });
    
    // Connect to existing buttons
    const startBtn = document.getElementById('btn-compass-start');
    const stopBtn = document.getElementById('btn-compass-stop');
    const applyBtn = document.getElementById('btn-compass-apply');
    
    if (startBtn) {
      startBtn.addEventListener('click', () => {
        window.d3Compass.startCompass();
        document.getElementById('compass-status').textContent = 'La bàn đang hoạt động...';
      });
    }
    
    if (stopBtn) {
      stopBtn.addEventListener('click', () => {
        window.d3Compass.stopCompass();
        document.getElementById('compass-status').textContent = 'La bàn đã dừng';
      });
    }
    
    if (applyBtn) {
      applyBtn.addEventListener('click', () => {
        if (window.d3Compass.selectedSector) {
          const directionSelect = document.getElementById('huong-nha');
          if (directionSelect) {
            const direction = window.d3Compass.directions.find(d => d.angle === window.d3Compass.selectedSector.angle);
            if (direction) {
              directionSelect.value = direction.name;
            }
          }
        }
      });
    }
  }
}
